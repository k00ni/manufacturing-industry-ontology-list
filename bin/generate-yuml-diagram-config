#!/usr/bin/env php
<?php

/**
 * This file generates config code for graph visualization on yuml.me.
 */

declare(strict_types=1);

/**
 * Saves information about ontologies and their interrelations.
 *
 * @var array<string,array<mixed>>
 */
$simplifiedOntologyList = [
    // could not found related ontology for this ontology IRI
    // BioPortal support contacted about the URL
    'http://data.bioontology.org/metadata/' => [
        'abbreviation' => 'obo',
        'key' => 'open_biological_and_biomedical_ontology_foundry',
        'rdf_file' => null,
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
        'ontology_iri' => 'http://purl.obolibrary.org/obo/',
    ],
    // could not found related ontology for this ontology IRI
    'http://www.ontologyrepository.com/CommonCoreOntologies/' => [
        'abbreviation' => '?',
        'key' => 'ontology_repository_common_core_ontologies',
        'rdf_file' => null,
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
        'ontology_iri' => 'http://www.ontologyrepository.com/CommonCoreOntologies/',
    ],
    // added because it doesn't reference a certain ontology, but seems to be a placeholder
    // which points to a list of ontologies (https://obofoundry.org/).
    // in RDF data you might see entries like "obo:RO_0001900" which point to an entry in
    // https://obofoundry.org/ontology/ro.html, which has http://purl.obolibrary.org/obo/ro.owl#
    // as ontology IRI.
    'http://purl.obolibrary.org/obo/' => [
        'abbreviation' => 'obo',
        'key' => 'open_biological_and_biomedical_ontology_foundry',
        'rdf_file' => null,
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
        'ontology_iri' => 'http://purl.obolibrary.org/obo/',
    ],
    // all Dublin Core IRIs (e.g. http://purl.org/dc/terms/, http://purl.org/dc/dcam/) point/redirect to
    // https://www.dublincore.org/specifications/dublin-core/dcmi-terms/
    // both DCTerms and DCElements also reference the same terms/elements
    'http://purl.org/dc/dcmitype/' => [
        'abbreviation' => 'dcmitype',
        'key' => 'dcmi_type',
        'rdf_file' => null,
        'ontology_iri' => 'http://purl.org/dc/dcmitype/',
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
    ],
    'http://purl.org/dc/dcam/' => [
        'abbreviation' => 'dcam',
        'key' => 'dcam',
        'rdf_file' => null,
        'ontology_iri' => 'http://purl.org/dc/dcam/',
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
    ],
    // GoodRelations vocabulary was merged into schema.org in 2012 and no longer has a RDF file of its own
    'http://purl.org/goodrelations/v1#' => [
        'abbreviation' => 'GR',
        'key' => 'good_relations_ontology',
        'rdf_file' => null,
        'ontology_iri' => 'http://purl.org/goodrelations/v1#',
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
    ],
    // Sometimes authors use https://schema.org/ instead of the original URL http://schema.org/
    // this entry is only for easing data management
    'https://schema.org/' => [
        'abbreviation' => 'Schema.org',
        'key' => 'schema_org',
        'rdf_file' => null,
        'ontology_iri' => 'https://schema.org/',
        'ignore_it' => true, // if true, it will be ignored when loading RDF file later on
    ],
];

// load CSV file and build simplified ontology list
foreach (array_map('str_getcsv', file(__DIR__.'/../ontologies.csv')) as $line => $entry) {
    if (0 == $line) {
        continue;
    }

    // build line with entry ID and label
    $key = strtolower($entry[0]);
    $key = str_replace([' ', '.'], '_', $key);
    $key = str_replace(',', '', $key);
    $key = str_replace('-', '_', $key);

    // abbreviation
    $abbreviation = strtolower($entry[2]);
    $abbreviation = str_replace('-', '', $abbreviation);

    // related RDF file
    $ontologyIRI = $entry[7];
    if (false === str_starts_with($entry[7], 'http')) {
        // if ontology IRI isn't starting with http, therefore its not an URI
        // in this case use RDF file instead
        $ontologyIRI = $entry[6];
    }

    // related RDF file
    $rdfFile = (string) $entry[8];

    if (0 == strlen($rdfFile)) {
        // throw new Exception($title.' has no RDF file URL');
        continue;
    }

    $simplifiedOntologyList[$ontologyIRI] = [
        'abbreviation' => $abbreviation,
        'key' => $key,
        'rdf_file' => $rdfFile,
        'ontology_iri' => $ontologyIRI,
        'ignore_it' => false,
    ];
}

// ignore SSL problems in https-based connections
$context = stream_context_create([
    'ssl' => [
      'verify_peer' => false,
      'verify_peer_name' => false,
    ]
]);

$fileContent = '';

var_dump($simplifiedOntologyList);

foreach ($simplifiedOntologyList as $iri => $entry) {
    if (true === $entry['ignore_it']) {
        // ignore this entry (for reasons look above)
        continue;
    } elseif (str_contains($entry['rdf_file'], 'Information not available')) {
        continue;
    } else {
        // download file and read content
        $rdfFileContent = file_get_contents($entry['rdf_file'], false, $context);
    }

    // assume its RDF/Turtle
    if (
        str_contains($entry['rdf_file'], '.n3')
        || str_contains($entry['rdf_file'], '.ttl')
    ) {
        $regex = '/@prefix\s+[a-z]+:\s*<(.*?)>/msi';
    } else {
        // XML file
        $regex = '/xmlns:[a-z]+="(.*?)"/smi';
    }

    if (0 < preg_match_all($regex, $rdfFileContent, $namespaceIRIs)) {
        $list = [];

        // go through the list of namespace IRIs
        foreach ($namespaceIRIs[1] as $iri) {
            // get related ontology title
            if (isset($simplifiedOntologyList[$iri])) {
                // current ontology
                $from = strtolower($entry['key']);
                // referenced ontology
                $to = strtolower($simplifiedOntologyList[$iri]['key']);

                // add line to file content
                $fileContent .= '['.$from.']->['.$to.']'.PHP_EOL;
            } else {
                echo PHP_EOL.'In '. $entry['key'].' found unknown namespace IRI: '.$iri;
            }
        }
    } else {
        throw new Exception($entry['key'].': No related namespaces found!');
    }
}

file_put_contents(__DIR__.'/../yuml-diagram-config.txt', $fileContent);

echo PHP_EOL;